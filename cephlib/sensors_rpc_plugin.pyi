from typing import Callable, Any, Optional, List, Dict, Tuple, NewType, NamedTuple, Iterator, IO

Pid = NewType('Pid', str)
AnyFunc = Callable[..., Any]
PrefixList = Optional[List[str]]
SensorDict = Dict[str, int]
SENSOR2DEV_TYPE = ...  # type: Dict[str, str]
ALL_STAGES = ...  # type: List[str]
BASIC_STAGES = ...  # type: List[str]
CephOp = NamedTuple("CephOp", "age descr_idx duration initiated_at status stages extra1 extra2")
CEPH_OP_DESCR_IDX = ...  # type: Dict[str, int]
waiting_subop = ...  # type: str
sub_op_commit = ...  # type: str
sub_op_applied = ...  # type: str


class CephSensor:
    @classmethod
    def parse_op(cls, op: Dict[str, Any]) -> CephOp: ...

    @classmethod
    def unpack_historic(cls, packed: bytes) -> Iterator[CephOp]: ...

    @classmethod
    def unpack_historic_fd(cls, fd: IO[bytes], size: int) -> Iterator[CephOp]: ...

def provides(name: str) -> Callable[[AnyFunc], AnyFunc]: ...
def get_pid_name(pid: Pid) -> str: ...
def pid_stat(pid: Pid) -> float: ...
def get_mem_stats(pid : Pid) -> Tuple[int, int]: ...
def get_ram_size() -> int: ...
def unpack_rpc_updates(res_tuple: Tuple[Dict[bytes, Tuple[int, int, bytes]], bytes, bytes]) \
    -> Tuple[str, Any, bool]: ...
def pack_ceph_op(op: CephOp) -> bytes: ...
def parse_ops_timings(ops_list: List[List[Any]], op_type: str, expected_evts: List[str]) -> List[Dict[str, float]]: ...